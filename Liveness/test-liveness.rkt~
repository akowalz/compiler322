#lang racket

(require rackunit
         "liveness.rkt")

; label? tests
(check-equal? (label? ':hello) #t)
(check-equal? (label? 5) #f)
(check-equal? (label? '_hello) #f)
(check-equal? (label? '(a b 5)) #f)

; preds tests (fix)
(check-equal? (preds 0 '(:rrr (eax <- 3) (eax += 4) (ebx <- 4) (goto :rrr)))
              '(4))
(check-equal? (preds 3 '(:f (eax <- 3) (eax += 4) :rrr (ebx <- 4) (goto :rrr)))
              '(5 2))
(check-equal? (preds 4 '(:f (eax <- 3) (cjump 2 < 4 :f :rrr) (eax += 4) :rrr (ebx <- 4) (goto :rrr)))
              '(6 2 3))
(check-equal? (preds 2 '(:f (return) (eax <- 1)))
              '())
(check-equal? (preds 2 '(:f (call :g) (eax <- 1)))
              '())
(check-equal? (preds 2 '(:f (tail-call :g) (eax += 1)))
              '())
(check-equal? (preds 3 '(:f (cjump eax = eax :here :there) :here :there))
              '(1))
(check-equal? (preds 2 '(:f (cjump eax = 2 :l1 :l2) :lx :l1 :l2))
              '())
(check-equal? (preds 2 '(:f (cjump eax < 1 :l1 :l2) (eax <- 3) :l1 :l2))
              '())
(check-equal? (preds 2 '(:f (goto :g) (eax <- 1) :g))
              '())

(check-equal? (preds 3 '(:f (eax <- 1) (cjump 2<4 :f :f) (eax <- 4)))
              '())


; all-preds tests (fix)
(check-equal? (all-preds '(:f (eax <- 1)))
              '(() (0)))
(check-equal? (all-preds '(:f (eax <- 1) (edx <- 2)))
              '(() (0) (1)))
(check-equal? (all-preds '(:f (eax += 5) ((mem ebp -4) <- 11)))
              '(() (0) (1)))
(check-equal? (all-preds '(:f (eax += 5) :g ((mem ebp -4) <- 11)))
              '(() (0) (1) (2)))
(check-equal? (all-preds '(:f (eax += 5) (goto :g) :g))
              '(() (0) (1) (2)))
(check-equal? (all-preds
               '(:f (cjump eax = eax :here :there) :here (eax <- 0) :there (eax <- 1)))
              '(() (0) (1) (2) (1 3) (4)))
(check-equal? (all-preds '(:g (eax <- 1) (eax <- (print eax)) (x <- 5)))
              '(() (0) (1) (2)))
(check-equal? (all-preds '(:f (x <- 1) (y <- 2) (edx <- x = y)))
              '(() (0) (1) (2)))
; this is a really tough test case
; :h is actually unreachable, becuase the goto will always skip it
; so, if :h is unreachable, :g cannot be reached through h
; to fix: maybe add a recursive call on on each node to check? could get expensive
(check-equal? (all-preds 
               '(:f (eax += 5) (goto :g) :h :g))
               '(() (0)        (1)       () (2)))
; also fails, because (x <- 5) can't be reached
(check-equal? (all-preds '(:f (cjump eax < eax :l1 :l2) (x <- 5) :l1 :l2))
              '(() (0) () (1) (1 3)))
; here's a very simple one to try fixing
(check-equal? (all-preds '(:g (goto :r) :q :r))
              '(() (0) () (1)))
;a also toug we never configured calls either
(check-equal? (all-preds '(:g (call :h) (eax += 1)))
              '(() (0) ()))
(check-equal? (all-preds '(:h (return) :g))
              '(() (0) ()))
(check-equal? (all-preds '(:g (tail-call :h) (x <- 10)))
              '(() (0) ()))
(check-equal? (all-preds '(:g (eax <- :fun) (tail-call :fun) (eax <- 1)))
              '(() (0) (1) ()))

;copy not killed test
(check-equal? (copy-not-killed '(() (a) (b)) '((a) (b) ()) '((a) () ()))
              '(() (a b) (b)))
(check-equal? (copy-not-killed '(() (eax edx x y) (z))
                               '((ebx eax) (eax edx x y z) ())
                               '((ebx) () ()))
              '((eax) (y x edx eax z) (z)))
;make list of empties test
(check-equal? (make-list-of-empties 3)
              '(() () ()))

; get new outs
(check-equal? (get-new-outs '((a) (b)) '(0 1) '())
              '(b a))
(check-equal? (get-new-outs '((a) (b)) '(0 1) '(c))
              '(b c a))
(check-equal? (get-new-outs '((a) (b)) '(0) '(c))
              '(c a))

(check-equal? (copy-inds '((a) (b) (c)) '((2 1) (1) (0)) '(() () ()))
              '((b c) (b) (a))) 
(check-equal? (copy-inds '(() (eax) (x eax))
                         '((0) (2 1) (1))
                         '((edx) () ()))
             '((edx) (x eax) (eax)))



(check-equal? (find-refs ':hello '(:f (cjump 1 = 1 :hello :f) (goto :hello) :hello))
              '(2 1))